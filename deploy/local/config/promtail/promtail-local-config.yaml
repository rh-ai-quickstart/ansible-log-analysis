server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:

# TODO: Uncomment this when we have a way to collect logs from aap-mock container (work in progress)
# # Collect logs from aap-mock container (via Docker socket)
# # This mirrors the OpenShift setup where Alloy collects from aap-mock pods
# - job_name: aap-mock
#   docker_sd_configs:
#     - host: unix:///var/run/docker.sock
#       refresh_interval: 5s
#       filters:
#         - name: name
#           values: ["aap-mock"]
#   relabel_configs:
#     - source_labels: ['__meta_docker_container_name']
#       regex: '/(.*)'
#       target_label: 'container'
#     - source_labels: ['__meta_docker_container_log_stream']
#       target_label: 'logstream'
#     - source_labels: ['__meta_docker_container_label_com_docker_compose_service']
#       target_label: 'service'
#     - replacement: 'aap-mock'
#       target_label: 'job'

# Single job for all Ansible logs
- job_name: ansible_logs
  static_configs:
  - targets:
      - localhost
    labels:
      # Expected path: /var/log/ansible_logs/<cluster_name>/<job_name>.txt
      __path__: /var/log/ansible_logs/*/*.txt

  pipeline_stages:
    # Stage 1: Multiline Aggregation
    - multiline:
        firstline: '^(PLAY\s+\[|TASK\s+\[|RUNNING HANDLER\s+\[|PLAY\s+RECAP\s+\*+|NO MORE HOSTS LEFT\s+\*+|Vault password)'
        max_lines: 2000

    # Stage 2: Extract cluster_name from filename path
    - regex:
        source: filename
        expression: '/var/log/ansible_logs/(?P<cluster_name>[^/]+)/'

    # Stage 3: Promote cluster_name to label
    - labels:
        cluster_name: ''

    # Stage 4: Extract markers for each log type (regex only sets field if it matches)
    - regex:
        expression: '^TASK\s+\[(?P<task_name_marker>[^\]]+)\]'
    - regex:
        expression: '^PLAY\s+RECAP\s+(?P<recap_marker>\*+)'
    - regex:
        expression: '^PLAY\s+\[(?P<play_name_marker>[^\]]+)\]\s+\*+'

    # Stage 3: Extract timestamp from log content (if exists)
    - regex:
        expression: '(?P<real_timestamp>\w+ \d{2} \w+ \d{4}  \d{2}:\d{2}:\d{2} [+-]\d{4})'

    # Stage 4: Extract status from TASK entries with override logic
    # 4a: Extract 'included' status first (lowest priority, different format: "included: path for hostname")
    - regex:
        expression: '(?P<status>included):\s+\S+\s+for\s+(?P<host>\S+)'

    # 4b: Extract standard status occurrence (ok, changed, skipping - overrides included)
    - regex:
        expression: '(?P<status>ok|changed|skipping):\s+\[(?P<host>[^\]]+)\]'

    # 4c: Override status if 'failed' or 'fatal' appears anywhere
    - regex:
        expression: '(?P<status>failed|fatal):\s+\[(?P<host>[^\]]+)\]'

    # 4d: Override status if "...ignoring" appears at line end
    - regex:
        expression: '\.\.\.(?P<status>ignoring)\s*$'

    # Stage 5: Promote markers to temporary labels (needed for match selectors)
    - labels:
        task_name_marker: ''
        recap_marker: ''
        play_name_marker: ''

   # Stage 6: Set log_type based on which marker exists
    - match:
        selector: '{task_name_marker!=""}'
        stages:
          - static_labels:
              log_type: 'task'

    - match:
        selector: '{recap_marker!="",log_type=""}'
        stages:
          - static_labels:
              log_type: 'recap'

    - match:
        selector: '{play_name_marker!="",log_type=""}'
        stages:
          - static_labels:
              log_type: 'play'

    # Stage 7: Fallback for unmatched entries
    - match:
        selector: '{log_type=""}'
        stages:
          - static_labels:
              log_type: 'other'


    # Stage 11: Convert log_type, real_timestamp, and status to structured metadata
    - structured_metadata:
        log_type:
        real_timestamp:

    # Stage 12: Promote status to label
    - labels:
        status: ''

    # Stage 13: Keep only desired labels (filename and cluster_name)
    - labelallow:
        - filename
        - cluster_name
        - status